require("dotenv").config();
const Discord = require("discord.js");
const Canvas = require("canvas");
const fs = require("fs");
const client = new Discord.Client();

//All the different activities of the bot
/*	Possible Status:
        -Playing with your heart
        -Watching TurboHacks get destroyed
        -Watching your every move
*/
const presenceList = [
  {
    activity: {
      name: "today's sponsor: Audible",
      type: "LISTENING",
    },
    status: "idle",
  },
  {
    activity: {
      name: "Mind Games",
      type: "PLAYING",
    },
    status: "dnd",
  },
  {
    activity: {
      name: "your conversations",
      type: "LISTENING",
    },
    status: "online",
  },
  {
    activity: {
      name: "you",
      type: "WATCHING",
    },
    status: "online",
  },
  {
    activity: {
      name: "your requests",
      type: "LISTENING",
    },
    status: "online",
  },
  {
    activity: {
      name: "Discord Deception",
      type: "PLAYING",
    },
    status: "online",
  },
  {
    activity: {
      name: "with a blindfold on",
      type: "PLAYING",
    },
    status: "online",
  },
  {
    activity: {
      name: "with tilt controls",
      type: "PLAYING",
    },
    status: "online",
  },
  {
    activity: {
      name: "Bowser's Big Bean Burrito 2| Trying to get the world record.",
      type: "STREAMING",
      url: "https://www.twitch.tv/izadoodle",
    },
    status: "online",
  },
  {
    activity: {
      name: "SERVERS",
      type: "PLAYING",
    },
    status: "online",
  },
  {
    activity: {
      name: "you vote with +vote",
      type: "WATCHING",
    },
    status: "online",
  },
  {
    activity: {
      name: "You Like a Fiddle",
      type: "PLAYING",
    },
    status: "idle",
  },
];

//The good night reactions for the gn command
const goodnights = [
  ["Arrivederci", "üëã"],
  ["Good Night", "üò¥"],
  ["See You Later", "üèÉ"],
  ["Later", "üåä"],
  ["Bye", "üëã"],
  ["Sleep tight", "üõèÔ∏è"],
  ["Farewell", "üåä"],
  ["Finally", "üôå"],
  ["Minecraft", "Minecraft Mobs"],
];

//List of locations for wwd command
var locations = [
  "Logjam Lumberyard",
  "Sleepy Sound",
  "Shifty Shafts",
  "Rave Cave",
  "The Daily Bugle",
  "The Joneses",
  "Coney Crossroads",
  "Tilted Towers",
  "Tilted Towers",
  "Sanctuary",
  "Rocky Reels",
  "Condo Canyon",
  "Greasy Grove",
  "Reality Falls",
  "Chonker's Speedway",
  "Synapse Station",
];
//List of endings to sentence
var endings = [
  "This is going to be quick one...",
  "Godspeed.",
  "May the Force be with you.",
  "Arrivederciüëã",
  "Au Revoirüëã",
  "Say≈çnaraüëã",
  "Ciaoüëã",
  "May the odds be ever in your favor.",
  "Watch out for the tornado!",
  "Get that dub!",
];

//Keeping track of how many commands are used so that I know how often the bot does stuff
var commandCount = 0;
var voiceCount = 0;
var bruhCount = 0;
var gnCount = 0;

//The help command attachment
const commandList = new Discord.MessageEmbed()
  .setColor("#82be42")
  .setTitle("H&R Bot Commands:")
  .setURL("https://github.com/PiyushMewada/HandR-bot")
  .setThumbnail("https://i.imgur.com/I2IrB4s.png")
  .addFields(
    {
      name: "**Text Channel Commands:**",
      value:
        "**+headout**: Displays the 'aight imma head out' gif\n" +
        "**+invite**: Gets an invite link for the bot so that you can add it to another server\n" +
        '**+poll**: Creates a poll. Separate each option with quotes. You can have upto 10 options. Ex: +poll Title "option" "option2"\n' +
        "**+ping**: Replies with Pong! to test if bot is online\n" +
        "**+server**: Displays server information\n" +
        "**+sonicsays *text***: Gets Sonic to say the *text*\n" +
        "**+tourney**: Creates a tournament bracket. Ex. +tourney * Person1 * Person2 * Person3 * Person4\n" +
        "**+tourneyr**: Same as +tourney, but randomizes the participants\n" +
        "**+tourneys**: Same as +tourney, but seeds the participants. Enter them in order of skill level\n" +
        "**+vote**: Gives a link to vote for the bot. You get a reward for voting!\n" +
        "**+wwd**: Tells you where to drop in Fortnite\n" +
        "**+wipe *n***: Searches the last n (max 100) messages and deletes bot messages and commands within the last 2 weeks. Default is 50\n" +
        "**+#1 *text***: Creates a Victory Royale image with custom *text*\n",
    },
    {
      name: "**Voice Channel Commands:**",
      value:
        "**+backup**: Back it up Terry!\n" +
        "**+clap**: Applause\n" +
        "**+default**: Default dance from Fortnite\n" +
        "**+deez**: Deez Nuts\n" +
        "**+gotem**: Ladies and Gentlemen, we got em,\n" +
        "**+haha**: Laughtrack\n" +
        "**+horn**: MLG-AirHorn\n" +
        "**+jail**: Law and Order\n" +
        "**+kronk**: It's all coming together\n" +
        "**+mimimi**: Snore\n" +
        "**+mogus**: Among Us Role Reveal\n" +
        "**+no**: Talking Ben No\n" +
        '**+ohyeah**: Vector\'s iconic line: "Oh yeah"\n' +
        "+**oof**: OOF sound\n" +
        "**+reverse**: Put it in reverse Terry!\n" +
        "**+rickroll**: Try it out\n" +
        "**+scoob**: Scooby-doo laugh\n" +
        "**+spongedrama**: Spongebob Drama Sound Effect\n" +
        "**+spongefail**: Spongebob Fail Sound Effect\n" +
        "**+stink**: Stinky Boi\n" +
        "**+yea**: Talking Ben Yea\n" +
        '**+yeet**: "YEET"\n' +
        "**+leave**: Makes bot leave the voice channel\n",
    }
  );

//The hidden help command attachment
const hiddenCommandList = new Discord.MessageEmbed()
  .setColor("#82be42")
  .setTitle("H&R Bot Commands:")
  .setURL("https://github.com/PiyushMewada/HandR-bot")
  .setThumbnail("https://i.imgur.com/I2IrB4s.png")
  .addFields(
    {
      name: "**Text Channel Commands:**",
      value:
        "**+headout**: Displays the 'aight imma head out' gif\n" +
        "**+invite**: Gets an invite link for the bot so that you can add it to another server\n" +
        '**+poll**: Creates a poll. Separate each option with quotes. You can have upto 10 options. Ex: +poll Title "option" "option2"\n' +
        "**+ping**: Replies with Pong! to test if bot is online\n" +
        "**+server**: Displays server information\n" +
        "**+sonicsays *text***: Gets Sonic to say the *text*\n" +
        "**+tourney**: Creates a tournament bracket. Ex. +tourney * Person1 * Person2 * Person3 * Person4\n" +
        "**+tourneyr**: Same as +tourney, but randomizes the participants\n" +
        "**+tourneys**: Same as +tourney, but seeds the participants. Enter them in order of skill level\n" +
        "**+vote**: Gives a link to vote for the bot. You get a reward for voting!\n" +
        "**+wwd**: Tells you where to drop in Fortnite\n" +
        "**+wipe *n***: Searches the last n (max 100) messages and deletes bot messages and commands within the last 2 weeks. Default is 50\n" +
        "**+#1 *text***: Creates a Victory Royale image with custom *text*\n",
    },
    {
      name: "**Voice Channel Commands:**",
      value:
        "**+backup**: Back it up Terry!\n" +
        "**+clap**: Applause\n" +
        "**+default**: Default dance from Fortnite\n" +
        "**+deez**: Deez Nuts\n" +
        "**+dum**: Calls you dumb\n" +
        "**+gotem**: Ladies and Gentlemen, we got em,\n" +
        "**+haha**: Laughtrack\n" +
        "**+horn**: MLG-AirHorn\n" +
        "**+loss**: Losing sound effect\n" +
        "**+jail**: Law and Order\n" +
        "**+kronk**: It's all coming together\n" +
        "**+mad**: When you make people mad\n" +
        "**+mimimi**: Snore\n" +
        "**+mogus**: Among Us Role Reveal\n" +
        "**+no**: Talking Ben No\n" +
        '**+ohyeah**: Vector\'s iconic line: "Oh yeah"\n' +
        "+**oof**: OOF sound\n" +
        "**+rekt**: Crowd going wild\n" +
        "**+reverse**: Put it in reverse Terry!\n" +
        "**+rickroll**: Try it out\n" +
        "**+sans**: Plays first notes of Megalovania\n" +
        "**+scoob**: Scooby-doo laugh\n" +
        "**+spongedrama**: Spongebob Drama Sound Effect\n" +
        "**+spongefail**: Spongebob Fail Sound Effect\n" +
        "**+stink**: Stinky Boi\n" +
        "**+yea**: Talking Ben Yea\n" +
        '**+yeet**: "YEET"\n' +
        "**+leave**: Makes bot leave the voice channel\n",
    },
    {
      name: "**Hidden Commands:**",
      value:
        "**Text**:\n" +
        "**+anikait**: Sends an image of his car exploding\n" +
        "**+ansh**: Calls Justin a dumbass\n" +
        "**+help, +info**: Sends command list\n" +
        "**+help all, +info all, +ia**: Sends hidden command list\n" +
        "**+freemoney, +piyush, +rickroll**: Calls you a fool\n" +
        "**Voice**:\n" +
        "**+butt**: Ansh getting boned\n" +
        "**+donkey**: Gordom Ramsay calling you a donkey\n" +
        "**+getover**: Trevor getting over\n" +
        "**+smooth**: Smooth Moves from Fortnite\n",
    },
    {
      name: "**If a message includes:**",
      value:
        "**bruh**: react with B R U H\n" +
        "**good night/gn**: reply with a farewell and react to message\n" +
        "**sda**: reply with sad waluigi\n" +
        "**thirsty**: react with Justin drinking\n" +
        "**?**: reply with question mark image\n",
    }
  );

//Embed that has the invite link for the bot
const botInvite = new Discord.MessageEmbed()
  .setColor("#82be42")
  .setTitle("Invite the Bot to Your Server!")
  .setURL(
    "https://discord.com/api/oauth2/authorize?client_id=707642874766032916&permissions=8&scope=bot"
  )
  .setThumbnail("https://i.imgur.com/I2IrB4s.png")
  .setDescription("Click the title to add the bot!");

const voteLink = new Discord.MessageEmbed()
  .setColor("#82be42")
  .setTitle("Vote to get a reward!")
  .setURL("https://top.gg/bot/707642874766032916/vote")
  .setThumbnail("https://i.imgur.com/I2IrB4s.png")
  .setDescription("Click the title to vote for the bot!");

//Tournament Dictionary
var tournamentDict = [];

//Joke Dictionary
var jokeList = [];
fs.readFile("images/Jokes.txt", (err, fileContents) => {
  if (err) throw err;

  jokeList = fileContents.toString().split(",");
});

//Function to get the index of the server from the tournament dictionary
function getServerIndex(dict, guildID) {
  for (i = 0; i < dict.length; i++) {
    if (dict[i].info.ID == guildID) {
      return i;
    }
  }
  return false;
}

//When the bot goes online
client.on("ready", () => {
  console.log(`Logged in as ${client.user.tag}!`);
  client.channels
    .fetch("758749523450789989")
    .then((channel) => {
      channel.send("Bot was restarted.");
    })
    .catch();

  if (Math.random() < 0.04) {
    const newPresence =
      presenceList[Math.floor(Math.random() * presenceList.length)];
    if (newPresence.activity.name.toString() == "SERVERS") {
      client.user.setPresence({
        activity: {
          name: `sound effects in ${client.guilds.cache.size.toString()} servers!`,
          type: "PLAYING",
        },
        status: "online",
      });
    } else {
      client.user.setPresence(newPresence);
    }
  }
});

//Whenever a message is sent
client.on("message", async (msg) => {
  if (msg.channel.id != "758749523450789989") {
    //If someone says chickin nogget then send a picture of a nugget
    if (msg.content.toLowerCase() == "chickin nogget") {
      const noggetAttachment = new Discord.MessageAttachment(
        "./images/nugget.jpg"
      );
      msg.channel.send(noggetAttachment);
    }

    //Sad Waluigi emoji auto-send
    /*if (msg.content.toLowerCase().includes("sda")) {
			msg.channel.send("<:Waluigi:718312850141216798>")
		}

		//Thirsty emoji auto-send
		if (msg.content.toLowerCase().includes("thirsty")) {
			msg.react("718313560186290207")

		}

		//If a message says bruh, reply with B R U H
		if (
			msg.content.toLowerCase().includes("bruh")) {
				//Increment the bruh count
				bruhCount++
				//Pick a random bruh reaction
				
				const randBruh = Math.random()
				if(randBruh < .83) {
					msg.react("üáß")
					msg.react("üá∑")
					msg.react("üá∫")
					msg.react("üá≠")
				} else if (randBruh < .89) {
					msg.channel.send("ùìë ùì° ùì§ ùìó")
				} else if (randBruh < .95) {
					msg.channel.send("ùîπ ‚Ñù ùïå ‚Ñç")
				} else {
					msg.channel.send("***B R U H***")
				}
		}*/

    //If message says Good Night reply with a goodbye message
    /*if ((msg.content.toLowerCase().includes("good night") || msg.content.toLowerCase().includes("goodnight") || msg.content.toLowerCase() === "gn") && !msg.author.bot) {
			//Increment gn count
			gnCount++
			/* //Get the time
			var date = new Date()
			var time = date.getHours()
			//msg.channel.send(time.toString())
			if(time > 13 || time < 2){
				if(Math.random() > .5){
					msg.react("üçâ")
					msg.react("730171341843464243")
					msg.channel.send("Isn't it a bit early to be sleeping already?")
				} 
				else {
					msg.react("730170498876702781")
					msg.channel.send("You can only sleep at night.")
				}
			} 
			else {
				//Pick a random phrase and emoji
				goodbye = goodnights[Math.floor(Math.random() * goodnights.length)]
				if (goodbye[0] == "Finally") {
					//If it is the finally emoji send this response
					msg.react("üôå")
					msg.react("ü•≥")
					msg.channel.send(`Finally, ${msg.author.username} is leaving. Now we can have some real fun.`)
				}
				else if (goodbye[0] == "Minecraft") {
					//Minecraft Mobs: Zombie, Skeleton, Creeper, Enderman. in order
					msg.react("718311214404599809")
					msg.react("718311214312325182")
					msg.react("718311214375239681")
					msg.react("718311864517525586")
					msg.channel.send(`You may not rest now, ${msg.author.username}, there are monsters nearby...`)
				} else {
					//For all others send this response and reaction
					msg.react(goodbye[1])
					msg.channel.send(goodbye[0] + ", " + msg.author.username)
				}
			}*/
    //}

    /*
		//Confused command, sends an image with question marks
		if (msg.content === "?") {
			const questionAttactment = new Discord.MessageAttachment("./images/questionmark.jpg");
			msg.channel.send(questionAttactment)
		}*/

    /*
		//Personal command for a friend. Whenever he says "wot", it replies
		if (msg.content.toLowerCase() === "wot" && msg.author.id == 488542158542995458) {
			msg.channel.send("Conner, that was not confusing in any way. What could you possibly not understand.")
		}
		*/

    /*//When someone votes for the bot at https://top.gg/bot/707642874766032916
    //I get a notification in this channel
    if (msg.channel.id == 735923945722740747) {
      //For the embeded message read the content
      msg.embeds.forEach((embed) => {
        //Get the User's ID so that the bot can message them
        const voterIDIndex = embed.description.indexOf("(id:");
        const voterID = embed.description.substring(
          voterIDIndex + 4,
          voterIDIndex + 22
        );

        //Search the cache for that user
        const voter = client.users.cache.find((v) => v.id == voterID);
        //Send the user a joke as a DM
        voter.createDM().then((dmChannel) => {
          dmChannel.send("Thanks for voting! Here's your reward:");
          dmChannel.send(jokeList[Math.floor(Math.random() * jokeList.length)]);
          dmChannel.send(
            "Make sure to vote again in 12 hours to hear another funny joke!"
          );
        });
      });
    }*/

    //If message is a command with prefix '+'
    if (msg.content.startsWith("+")) {
      //Add one to the command count
      commandCount++;

      //This is to monitor the commands used so that I can find out what is causing my bot to restart
      client.channels
        .fetch("758749523450789989")
        .then((channel) => {
          if (msg.channel.id != "758749523450789989") {
            channel.send(msg.content);
          }
        })
        .catch();

      //Set bot status to typing so you know it is working
      msg.channel.startTyping();

      //After an average of 25 commands, it'll change its status
      if (Math.random() < 0.04) {
        const newPresence =
          presenceList[Math.floor(Math.random() * presenceList.length)];
        if (newPresence.activity.name.toString() == "SERVERS") {
          client.user.setPresence({
            activity: {
              name: `sound effects in ${client.guilds.cache.size.toString()} servers!`,
              type: "PLAYING",
            },
            status: "online",
          });
        } else {
          client.user.setPresence(newPresence);
        }
        //msg.channel.send("You changed my status!");
      }

      //Switch case for all the commands
      switch (msg.content.substring(1)) {
        case "ping":
          //Ping the bot so you know it's online
          msg.reply("Pong!");
          break;
        // Future idea: Make 2 embeds and use reactions to switch between voice and text commands.
        case "help":
        case "info":
          //Send the info embeded message
          msg.channel.send(commandList);
          break;
        case "help all":
        case "helpall":
        case "infoall":
        case "info all":
        case "ia":
          //Sends hidden command list
          msg.channel.send(hiddenCommandList);
          break;
        case "server":
          //Gives server info (Taken from Tubrohacks)
          msg.channel.send(
            `Server name: ${msg.guild.name}\nTotal Members: ${msg.guild.memberCount}`
          );
          break;
        case "headout":
          //Sends a Spongebob gif and then deletes both the messages
          const attachment = new Discord.MessageAttachment(
            "https://media.giphy.com/media/S9nuoEQkwXUms2ZNaz/giphy.gif"
          );
          await msg.channel.send(attachment).then((headout) => {
            msg
              .delete({
                timeout: 5000,
              })
              .catch();
            headout
              .delete({
                timeout: 5000,
              })
              .catch();
          });
          break;
        case "ansh":
          //Custom command taken from Turbohacks
          msg.channel.send("Justin is a dumbass.", {
            tts: true,
          });
          break;
        case "megamoto":
          //Sends emojis
          msg.channel.send(
            "<:chunky:718313891372990524> <:spunky:718313891766992898>"
          );
          break;
        case "anikait":
          //Custom command for a friend, send an image
          const Camryattachment = new Discord.MessageAttachment(
            "./images/Camry.jpg"
          );
          msg.channel.send(Camryattachment);
          break;
        case "freemoney":
        case "piyush":
          //Custom hidden commands for memes. Sends an image
          const foolAttachment = new Discord.MessageAttachment(
            "./images/fool.jpg"
          );
          msg.channel.send(foolAttachment);
          break;
        case "wwd":
        case "Wwd":
          //Tells you where to drop in fortnite
          //Pick 2 random elements and use them to make a phrase
          msg.channel.send(
            `I think you should go to ${
              locations[Math.floor(Math.random() * locations.length)]
            }. ${endings[Math.floor(Math.random() * endings.length)]}`
          );
          break;
        case "invite":
          //Sends invite link
          msg.channel.send(botInvite);
          break;
        //case "vote":
        //  msg.channel.send(voteLink);
        //  break;
        case "status":
          //So I can manually change the status of the bot
          if (msg.author.id == 241052712458911744) {
            const newPresence =
              presenceList[Math.floor(Math.random() * presenceList.length)];
            if (newPresence.activity.name.toString() == "SERVERS") {
              client.user
                .setPresence({
                  activity: {
                    name: `sound effects in ${client.guilds.cache.size.toString()} servers!`,
                    type: "PLAYING",
                  },
                  status: "online",
                })
                .then(
                  msg.channel.send(
                    `Changed status to ${client.user.presence.activities.toString()}`
                  )
                );
            } else {
              client.user
                .setPresence(newPresence)
                .then(
                  msg.channel.send(
                    `Changed status to ${client.user.presence.activities.toString()}`
                  )
                );
            }
          } else {
            //Not a vaild command for people who aren't me
            msg.channel.send("That's not a valid command. Try +info for help.");
          }
          break;
        case "servers":
          //So I can look at the servers the bot is in
          if (msg.author.id == 241052712458911744) {
            var serverList = "";
            client.guilds.cache.forEach((server) => {
              serverList += server.name + "\n";
            });
            msg.channel.send(
              `Bot is in ${client.guilds.cache.size.toString()} servers.`
            );
            msg.channel.send(serverList);
          } else {
            //Not a vaild command for people who aren't me
            msg.channel.send("That's not a valid command. Try +info for help.");
          }
          break;
        case "stopTyping":
          //Force the bot to stop typing
          msg.channel.stopTyping(true);
          break;
        case "CommandCount":
        case "cc":
          //Gets the number of commands used if I use it
          if (msg.author.id == 241052712458911744) {
            msg.channel.send(
              `Commands Used: ${commandCount.toString()}\nText Commands Used: ${(
                commandCount - voiceCount
              ).toString()}`
            );
            msg.channel.send(
              `Voice Commands Used: ${voiceCount.toString()}\nI3ruh Count: ${bruhCount.toString()}\nGoodNight Count: ${gnCount.toString()}`
            );
          } else {
            //Not a vaild command for people who aren't me
            msg.channel.send("That's not a valid command. Try +info for help.");
          }
          break;
        //Voice Channel Commands
        case "ohyeah":
        case "yeet":
        case "horn":
        case "butt":
        case "rekt":
        case "deez":
        case "donkey":
        case "getover":
        case "haha":
        case "rickroll":
        case "smooth":
        case "default":
        case "loss":
        case "sans":
        case "dum":
        case "mad":
        case "oof":
        case "math":
        case "ligma":
        case "bonk":
        case "bnok":
        case "backup":
        case "reverse":
        case "clap":
        case "gotem":
        case "jail":
        case "kronk":
        case "mimimi":
        case "mogus":
        case "no":
        case "scoob":
        case "yea":
        case "stink":
        case "spongefail":
        case "spongedrama":
        case "morbin":
        case "growl":
          //Increment the voice command count
          voiceCount++;
          //Join voice channel of memeber or the first voice channel available
          var currentChannel = msg.guild.channels.cache.find(
            (ch) => ch.type == "voice" && ch.rawPosition == 0
          );
          if (msg.member.voice.channel) {
            currentChannel = msg.member.voice.channel;
          }
          const connection = await currentChannel.join().then((connection) => {
            var dispatcher;
            switch (msg.content.substring(1)) {
              case "ohyeah":
                //Vector's Oh Yeah
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/ohyeah.mp3"),
                  {
                    volume: 1.3,
                  }
                );
                break;
              case "yeet":
                //YEET
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/yeet.mp3"),
                  {
                    volume: 0.5,
                  }
                );
                break;
              case "horn":
                //Airhorn
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/horn.mp3"),
                  {
                    volume: 0.15,
                  }
                );
                break;
              case "butt":
                //Custom hidden command
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/inthebutt.mp3"),
                  {
                    volume: 1.4,
                  }
                );
                break;
              case "rekt":
                //Crowd
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/career.mp3"),
                  {
                    volume: 0.3,
                  }
                );
                break;
              case "deez":
                //Hidden Gordon Ramsay
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/deez.mp3"),
                  {
                    volume: 0.8,
                  }
                );
                break;
              case "donkey":
                //Hidden Gordon Ramsay
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/donkey.mp3"),
                  {
                    volume: 1.0,
                  }
                );
                break;
              case "getover":
                //Hidden friend commmand
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/getover.mp3"),
                  {
                    volume: 1.0,
                  }
                );
                break;
              case "haha":
                //Laughtrack
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/laughtrack.mp3"),
                  {
                    volume: 1.0,
                  }
                );
                break;
              /*case "clap":
                //Friend saying "ha gottem"
                msg.channel.send("That was a good one" + "üëèüëè");
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/claps.mp3"),
                  {
                    volume: 0.8,
                  }
                );
                break;*/
              case "rickroll":
                //Rickroll
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/roll.mp3"),
                  {
                    volume: 0.75,
                  }
                );
                break;
              case "smooth":
                //Smooth Moves from Fortnite
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/smooth.mp3"),
                  {
                    volume: 0.6,
                  }
                );
                break;
              case "default":
                //Default Dance from Fortnite
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/default.mp3"),
                  {
                    volume: 0.9,
                  }
                );
                break;
              case "loss":
                //Losing sound  effect from Price is Right
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/loss.mp3"),
                  {
                    volume: 0.5,
                  }
                );
                break;
              case "sans":
                //Sans theme
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/megalovania.mp3"),
                  {
                    volume: 0.9,
                  }
                );
                break;
              case "dum":
                //6ix9ine calling you dumb
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/dumb.mp3"),
                  {
                    volume: 0.2,
                  }
                );
                break;
              case "mad":
                //6ix9ine talking about being mad
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/mad.mp3"),
                  {
                    volume: 0.2,
                  }
                );
                break;
              case "oof":
                //Roblox oof sound
                const oofSounds = ["./sounds/oofR.mp3", "./sounds/oofMC.mp3"];
                dispatcher = connection.play(
                  fs.createReadStream(
                    oofSounds[Math.floor(Math.random() * oofSounds.length)]
                  ),
                  {
                    volume: 0.8,
                  }
                );
                break;
              case "math":
                //Advanced Math Music from Fortnite
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/advancedmath.mp3"),
                  {
                    volume: 0.4,
                  }
                );
                break;
              case "ligma":
                //Steve Jobs died of Ligma
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/ligma.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "bonk":
                //Plays Bonk Noise
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/bonk.mp3"),
                  {
                    volume: 1.2,
                  }
                );
                break;
              case "bnok":
                //Plays Bonk Noise louder
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/bonk.mp3"),
                  {
                    volume: 3,
                  }
                );
                break;
              case "backup":
                //Plays Bonk Noise louder
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/backup.mp3"),
                  {
                    volume: 0.6,
                  }
                );
                break;
              case "reverse":
                //Plays Bonk Noise louder
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/putitinreverse.mp3"),
                  {
                    volume: 0.6,
                  }
                );
                break;
              case "clap":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/clapping.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "gotem":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/gotem.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "jail":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/jail.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "kronk":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/kronk.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "mimimi":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/mimimi.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "mogus":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/mogus.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "no":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/no.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "scoob":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/scoob.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "yea":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/yea.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "stink":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/stink.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "spongefail":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/spongefail.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "spongedrama":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/spongedrama.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "morbin":
                dispatcher = connection.play(
                  fs.createReadStream("./sounds/morbin.mp3"),
                  {
                    volume: 0.7,
                  }
                );
                break;
              case "growl":
                //Roblox oof sound
                const growlSounds = [
                  "./sounds/growl1.mp3",
                  "./sounds/growl2.mp3",
                  "./sounds/growl3.mp3",
                  "./sounds/growl4.mp3",
                ];
                dispatcher = connection.play(
                  fs.createReadStream(
                    growlSounds[Math.floor(Math.random() * growlSounds.length)]
                  ),
                  {
                    volume: 0.7,
                  }
                );
                break;
              default:
                break;
            }
            //Once the audio clip finishes leave the channel
            //dispatcher.on("finish", () => {
            // currentChannel.leave();
            //});
            dispatcher.on("error", console.error);
          });
          break;
        case "leave":
          //For emergencies, make the bot leave
          msg.member.voice.channel.leave();
          break;
        default:
          //For commands that require more information afterwards:

          //Wipe command to remove bot messages and commands
          if (msg.content.substring(1, 5) === "wipe") {
            if (msg.content.length > 5) {
              //If there is an amount specified set it equal to that
              amount = parseInt(msg.content.substring(5));
            } else {
              //Default amount it 50
              amount = 50;
            }
            if (amount >= 0 && amount <= 100) {
              //Get the last 'amount' messages
              msg.channel.messages
                .fetch({
                  limit: amount,
                })
                .then((messages) => {
                  //Then filter the messages you want to delete (Bot messages, and the commands)
                  const botmessages = messages.filter(
                    (msg) =>
                      msg.author.bot ||
                      msg.content.startsWith("#") ||
                      msg.content.startsWith("_") ||
                      msg.content.startsWith("m.") ||
                      msg.content.startsWith("u!") ||
                      msg.content.startsWith("rpg ") ||
                      msg.content.startsWith("?") ||
                      msg.content.startsWith("~") ||
                      msg.content.startsWith("+") ||
                      msg.content.startsWith("p!") ||
                      msg.content.startsWith("!") ||
                      msg.content.startsWith("-") ||
                      msg.content.startsWith("$") ||
                      msg.content.startsWith("=")
                  );
                  //Delete them all at once
                  msg.channel.bulkDelete(botmessages, true);

                  //Send info message saying how many were deleted
                  msg.channel
                    .send(`Removed ${botmessages.size} messages`)
                    .then((tempMessage) => {
                      //React to it with Thanos, and then delete that message too
                      tempMessage.react("718312854973055027");
                      tempMessage
                        .delete({
                          timeout: 5000,
                        })
                        .catch();
                    });
                });
            } else {
              //If the amount is too high or too low use these responses
              if (amount > 100) {
                //Too many
                msg.channel.send("That's too many messages.");
              } else {
                //Less than 0
                msg.channel.send(
                  "How am I supposed to search a negative amount of messages?"
                );
              }
            }
          } else if (msg.content.substring(1, 10) === "sonicsays") {
            //Custom Sonic Image Command
            //Create the canvas and the sonicsays image
            const canvas = Canvas.createCanvas(600, 340);
            const ctx = canvas.getContext("2d");
            const background = await Canvas.loadImage("./images/sonicsays.jpg");

            //Draw the image on the canvas
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

            //Font and color selection
            ctx.font = "25px sans-serif";
            ctx.fillStyle = "#ffffff";

            //Split up the message by the spaces to divide into new lines
            var wordsArr = msg.content.substring(11).split(" ");
            var messageArr = [""];
            var editedMessage = "";
            var j = 0;
            for (var i = 0; i < wordsArr.length; i++) {
              //If the message gets too long, then add it to a new line
              if (messageArr[j].length + wordsArr[i].length > 27) {
                j++;
                messageArr[j] = "";
              }
              messageArr[j] += wordsArr[i] + " ";
            }

            //Create string with proper endlines
            for (i = 0; i < messageArr.length; i++) {
              editedMessage += messageArr[i] + "\n";
            }

            //Create text
            ctx.fillText(editedMessage, 20, 80, 350);

            //Send image
            const attachment = new Discord.MessageAttachment(
              canvas.toBuffer(),
              "sonicsays.png"
            );
            msg.channel.send(attachment);
          } else if (msg.content.substring(1, 3) === "#1") {
            //Custom Victory Royale Image
            //Create the canvas and the Victory Royale image
            const canvas = Canvas.createCanvas(850, 280);
            const ctx = canvas.getContext("2d");
            const background = await Canvas.loadImage("./images/Victory.png");

            //Draw image
            ctx.drawImage(background, 0, 0, canvas.width, canvas.height);

            //Font and color selection
            ctx.font = "58px sans-serif";
            ctx.fillStyle = "#ffffff";
            /*ctx.textAlign = "center"*/

            //Split up the message by the spaces to divide into new lines
            var wordsArr = msg.content.substring(4).split(" ");
            var messageArr = [""];
            var editedMessage = "";
            var j = 0;
            for (var i = 0; i < wordsArr.length; i++) {
              //If the message gets too long, then add it to a new line
              if (j < 2 && messageArr[j].length + wordsArr[i].length > 16) {
                j++;
                messageArr[j] = "";
              }
              messageArr[j] += wordsArr[i] + " ";
            }

            //Create the string with proper endlines
            for (i = 0; i < messageArr.length; i++) {
              editedMessage += messageArr[i] + "\n";
            }

            //Create text
            ctx.rotate(-0.02 * Math.PI);
            ctx.fillText(editedMessage, 210, 120);
            ctx.strokeText(editedMessage, 210, 120);

            //Send image
            const attachment = new Discord.MessageAttachment(
              canvas.toBuffer(),
              "Victory.png"
            );
            msg.channel.send(attachment);
          } else if (msg.content.substring(1, 5) === "poll") {
            //Create a Poll
            //Split the message by the '""' divider
            var pollParts;
            if (msg.content.includes('"')) {
              pollParts = msg.content.split('"');
            } else if (msg.content.includes("‚Äú")) {
              pollParts = msg.content.split("‚Äú");
            }
            if (pollParts.length < 5) {
              //If there is something missing send this response to tell them how to format it
              msg.channel.send(
                'There is something missing from the poll, you need at least 2 options that are in quotes. Ex: +poll Title "option" "option2".'
              );
            } else if (pollParts.length > 21) {
              //If they use too many options then reply with this
              msg.channel.send("The max number of options is 10.");
            } else {
              //Creating a poll embeded message
              const Poll = new Discord.MessageEmbed()
                .setColor("#70c4c2")
                .setAuthor(
                  pollParts[0].substring(6),
                  "https://images-na.ssl-images-amazon.com/images/I/51cOM2ZPaoL.png"
                );

              //Create one string for all the options with new lines
              var optionText = "";
              var otherCounter = 1;
              for (i = 1; i < pollParts.length; i += 2) {
                optionText +=
                  otherCounter.toString() + ". " + pollParts[i] + "\n";
                otherCounter++;
              }

              //Set the options in the description
              Poll.setDescription(optionText);

              //The voting system is based on the reactions to the image
              //So react with the appropriate amount of options
              msg.channel.send(Poll).then((pollMessage) => {
                pollMessage.react("1Ô∏è‚É£");
                pollMessage.react("2Ô∏è‚É£");
                if (pollParts.length > 6) {
                  pollMessage.react("3Ô∏è‚É£");
                  if (pollParts.length > 8) {
                    pollMessage.react("4Ô∏è‚É£");
                    if (pollParts.length > 10) {
                      pollMessage.react("5Ô∏è‚É£");
                      if (pollParts.length > 12) {
                        pollMessage.react("6Ô∏è‚É£");
                        if (pollParts.length > 14) {
                          pollMessage.react("7Ô∏è‚É£");
                          if (pollParts.length > 16) {
                            pollMessage.react("8Ô∏è‚É£");
                            if (pollParts.length > 18) {
                              pollMessage.react("9Ô∏è‚É£");
                              if (pollParts.length > 20) {
                                pollMessage.react("üîü");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              });
            }
          } else if (
            msg.content.substring(1, 8) === "tourney" &&
            !msg.author.bot
          ) {
            //If there isn't a tournament happening then make one
            if (!tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]) {
              //Create a tournmanet bracket
              var tourneyParticipants = msg.content.split(" * ");
              tourneyParticipants.shift();
              if (
                tourneyParticipants.length <= 128 &&
                tourneyParticipants.length >= 4
              ) {
                if (msg.content.substring(8, 9) === "r") {
                  //If the tournament is seeded randomly then randomize the participants array
                  //Shuffling the array with Fisher-Yates Algorithm
                  var iterator = tourneyParticipants.length,
                    temp,
                    selection;
                  // While there remain elements to shuffle
                  while (iterator) {
                    // Pick a remaining element
                    selection = Math.floor(Math.random() * iterator--);

                    // And swap it with the current element.
                    temp = tourneyParticipants[iterator];
                    tourneyParticipants[iterator] =
                      tourneyParticipants[selection];
                    tourneyParticipants[selection] = temp;
                  }
                } else if (msg.content.substring(8, 9) === "s") {
                  //If they want to seed the participants then this will put them in the right spot
                  if (
                    tourneyParticipants.length == 4 ||
                    tourneyParticipants.length == 8 ||
                    tourneyParticipants.length == 16 ||
                    tourneyParticipants.length == 32 ||
                    tourneyParticipants == 64
                  ) {
                    slice = 1;
                    while (slice < tourneyParticipants.length / 2) {
                      temp = tourneyParticipants.slice();
                      tourneyParticipants = [];
                      while (temp.length > 0) {
                        tourneyParticipants = tourneyParticipants.concat(
                          temp.splice(0, slice)
                        );
                        tourneyParticipants = tourneyParticipants.concat(
                          temp.splice(-slice, slice)
                        );
                      }
                      slice *= 2;
                    }
                  } else {
                    //Function for seeded tournaments otherwise: https://stackoverflow.com/questions/5770990/sorting-tournament-seeds/45572051#45572051
                    //Will wait til I understand it to implement
                    msg.channel.send(
                      "Currently seeded tournaments only work with 4, 8, 16, 32, or 64 participants."
                    );
                  }
                }
                //Send starting message
                msg.channel.send(
                  "Tournament is starting with " +
                    tourneyParticipants.length +
                    " players!"
                );

                //Fill the tournament with byes so that there are a power of 2 number of participants
                var i = 1;
                if (tourneyParticipants.length > 64) {
                  while (tourneyParticipants.length != 128) {
                    tourneyParticipants.splice(i, 0, -1);
                    i += 2;
                  }
                } else if (tourneyParticipants.length > 32) {
                  while (tourneyParticipants.length != 64) {
                    tourneyParticipants.splice(i, 0, -1);
                    i += 2;
                  }
                } else if (tourneyParticipants.length > 16) {
                  while (tourneyParticipants.length != 32) {
                    tourneyParticipants.splice(i, 0, -1);
                    i += 2;
                  }
                } else if (tourneyParticipants.length > 8) {
                  while (tourneyParticipants.length != 16) {
                    tourneyParticipants.splice(i, 0, -1);
                    i += 2;
                  }
                } else if (tourneyParticipants.length > 4) {
                  while (tourneyParticipants.length != 8) {
                    tourneyParticipants.splice(i, 0, -1);
                    i += 2;
                  }
                }

                //Create a tournament in the dictionary
                tournamentDict.push({
                  info: {
                    ID: msg.guild.id,
                    winners: tourneyParticipants.slice(),
                    First: 0,
                    Second: 1,
                  },
                });
                msg.channel.send(
                  'After someone wins send, "+*name* won" to advance them.'
                );

                //For every 'bye' advance the other person forward
                while (
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.winners[
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.Second
                  ] == -1
                ) {
                  msg.channel.send(
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.First
                    ] + " gets a bye!"
                  );

                  //Delete the bye and iterate the vars
                  tournamentDict[
                    getServerIndex(tournamentDict, msg.guild.id)
                  ].info.winners.splice(
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.Second,
                    1
                  );
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.First++;
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.Second++;
                }
                //console.log(tournamentDict[getServerIndex(tournamentDict, msg.guild.id)].info.winners.toString())

                //Send message for first real tournament round
                msg.channel.send(
                  "Ok, now it is time for: " +
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.First
                    ] +
                    " and " +
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.Second
                    ] +
                    ". Good Luck!"
                );
              } else {
                //If they tried to enter an invalid amount of people
                if (tourneyParticipants.length > 128) {
                  msg.channel.send(
                    "That's too many participants. The max is 128."
                  );
                } else {
                  msg.channel.send(
                    "You need a minimum of 4 participants for a tournament. If you have less than that, then I'm sure you can make the bracket in your head." +
                      " Make sure you are formatting the command correctly. Put ' * ' in between each participant (with the spaces). Ex: +tourney * Person1 * Person2 * Person3 * Person4"
                  );
                }
              }
            } else {
              //If there is already a tournament happening in the server
              msg.channel.send(
                "There is already a tournament ocurring. Please wait for the current one to end before starting another. " +
                  "Or type +forceTourneyEnd to stop the ongoing tourney."
              );
            }
          } else if (msg.content.endsWith("won")) {
            //If the first person won the tournament round advance them and remove the second person
            if (tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]) {
              roundWinner = msg.content.split(" ");
              if (
                roundWinner[0].substring(1) ==
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.winners[
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.First
                  ] ||
                roundWinner[0].substring(1) ==
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.winners[
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.Second
                  ]
              ) {
                //Checks to see if it was the final round
                if (
                  tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                    .info.winners.length > 2
                ) {
                  //console.log("This is winners rn: " + tournamentDict[getServerIndex(tournamentDict, msg.guild.id)].info.winners.toString())

                  //Congratulate the winner and remove the loser
                  if (
                    roundWinner[0].substring(1) ==
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.First
                    ]
                  ) {
                    msg.channel.send(
                      "Congrats, " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.First
                        ] +
                        " on beating " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.Second
                        ] +
                        "."
                    );

                    //Send voice command and then delete it
                    msg.channel.send("+horn").then((message) => {
                      message.delete().catch();
                    });

                    //Remove loser and iterate the variables
                    tournamentDict[
                      getServerIndex(tournamentDict, msg.guild.id)
                    ].info.winners.splice(
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.Second,
                      1
                    );
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.First++;
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.Second++;
                  } else if (
                    roundWinner[0].substring(1) ==
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.Second
                    ]
                  ) {
                    msg.channel.send(
                      "Well done, " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.Second
                        ] +
                        ". It's sad to see " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.First
                        ] +
                        " be defeated."
                    );

                    //Send voice command and the delete it instantly
                    msg.channel.send("+ohyeah").then((message) => {
                      message.delete().catch();
                    });

                    //Remove Loser and iterate vars
                    tournamentDict[
                      getServerIndex(tournamentDict, msg.guild.id)
                    ].info.winners.splice(
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.First,
                      1
                    );
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.First++;
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.Second++;
                  }

                  //If the iterators are overflowing then reset them
                  if (
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.First >=
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners.length
                  ) {
                    tournamentDict[
                      getServerIndex(tournamentDict, msg.guild.id)
                    ].info.First = 0;
                    tournamentDict[
                      getServerIndex(tournamentDict, msg.guild.id)
                    ].info.Second = 1;
                  }

                  //Check to see if the next round is the finals or just another round
                  if (
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners.length > 2
                  ) {
                    //Output the next round message with the new players
                    const roundStarts = [
                      "Next round will be: ",
                      "Next up are: ",
                    ];
                    const roundStartsEndings = [
                      ". I know who I'm betting on.",
                      ". Best of Luck!",
                    ];

                    msg.channel.send(
                      roundStarts[
                        Math.floor(Math.random() * roundStarts.length)
                      ] +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.First
                        ] +
                        " and " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.Second
                        ] +
                        roundStartsEndings[
                          Math.floor(Math.random() * roundStartsEndings.length)
                        ]
                    );
                  } else {
                    //Send a random finals message
                    if (Math.random() > 0.5) {
                      msg.channel.send(
                        "Time for the finals! This will be a legendary duel between " +
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.winners[
                            tournamentDict[
                              getServerIndex(tournamentDict, msg.guild.id)
                            ].info.First
                          ] +
                          " and " +
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.winners[
                            tournamentDict[
                              getServerIndex(tournamentDict, msg.guild.id)
                            ].info.Second
                          ] +
                          "!"
                      );
                    } else {
                      msg.channel.send(
                        "Time for the finals! " +
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.winners[
                            tournamentDict[
                              getServerIndex(tournamentDict, msg.guild.id)
                            ].info.First
                          ] +
                          " will battle " +
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.winners[
                            tournamentDict[
                              getServerIndex(tournamentDict, msg.guild.id)
                            ].info.Second
                          ] +
                          " in a legendary duel!"
                      );
                    }
                  }
                } else {
                  //Send the ending message and delete the tournament from the dictionary
                  if (
                    roundWinner[0].substring(1) ==
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.First
                    ]
                  ) {
                    msg.channel.send(
                      "YOUR TOURNAMENT CHAMPION IS " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.First
                        ].toUpperCase() +
                        "! That was fun, let's do it again sometime!"
                    );

                    //Send voice command and then delete it
                    msg.channel.send("+ohyeah").then((message) => {
                      message.delete().catch();
                    });
                  } else if (
                    roundWinner[0].substring(1) ==
                    tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]
                      .info.winners[
                      tournamentDict[
                        getServerIndex(tournamentDict, msg.guild.id)
                      ].info.Second
                    ]
                  ) {
                    msg.channel.send(
                      "YOUR TOURNAMENT CHAMPION IS " +
                        tournamentDict[
                          getServerIndex(tournamentDict, msg.guild.id)
                        ].info.winners[
                          tournamentDict[
                            getServerIndex(tournamentDict, msg.guild.id)
                          ].info.Second
                        ].toUpperCase() +
                        "! It was a hard fought battle with many twists."
                    );

                    //Send voice command and then delete it
                    msg.channel.send("+horn").then((message) => {
                      message.delete().catch();
                    });
                  }

                  //Delete Tournament
                  tournamentDict.splice(
                    getServerIndex(tournamentDict, msg.guild.id),
                    1
                  );
                }
              } else {
                msg.channel.send(
                  "That is not one of the people in this round."
                );
              }
            }
            /* else {
							//If they to use the command without a tournament happening
							msg.channel.send("There isn't currently a tournament happening. Use +tourney to start one.")
						} */
          } else if (msg.content.substring(1) == "forceTourneyEnd") {
            if (tournamentDict[getServerIndex(tournamentDict, msg.guild.id)]) {
              //Stop the tournament and reset all the variables
              msg.channel.send("Tournament ended.");
              tournamentDict.splice(
                getServerIndex(tournamentDict, msg.guild.id),
                1
              );
            } else {
              //If they to use the command without a tournament happening
              msg.channel.send("There isn't a tournament happening right now.");
            }
          } else {
            //If the user types an invalid command reply with this
            msg.channel.send("That's not a valid command. Try +info for help.");
          }
          break;
      }
      //Stop the typing status after the bot is done
      msg.channel.stopTyping(true);
    }
  }
});
client.login(process.env.BOT_TOKEN);
